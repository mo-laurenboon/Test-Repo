""" 
This script takes the contents of the Grid_Data_Form.yml file and parses information to a json file that is added to 
grid-data base after being checked for duplicate entries. It also integrates sanity checks and collects warnings to flag 
potentially invalid entries.
"""


import argparse
import re
from pathlib import Path
import json
import os
from jsonschema import validate


def set_arg_parser():
    """
    Creates an argument parser to take the submitted issue body as an argument.

        :returns: Argument parser
    """
    parser = argparse.ArgumentParser(description="Open issue body")
    parser.add_argument("file", help="The issue body to process")
    args = parser.parse_args()
  
    return args


def add_form_content_warning(warning, warnings):
    """
    Creates a list of strings to store and concact any generated warnings or flags.

        :param warning: The warning message generated by sanity checks  
        :returns: None
    """
    warnings.append(warning)


def create_grid_dict(match, warnings):
    """
    Generates a dictionary format from the loaded issue body and cleans the key-value pairs to ensure consistent 
    formatting.

        :param grid: The name of the dictionary 
        :param match: The identified key value pairs from the issue body
        :returns: Dictionary containing the grid parameters from the form
        :raises ValueError: Raises an exception if the number of lat/long points connot be converted to an integer value
    """
    grid = {}
    for key, value in match:
        clean = key.strip().lower().replace(" ", "")
        if clean in ("latitudepoints", "longitudepoints"):
            try: 
                grid[clean] = int(value.strip())   
            except ValueError:
                print(f"Unable to convert {clean} to integer, storing value as string")
                add_form_content_warning("User has entered a non-integer value in a field that requires an integer.",
                                          warnings)
                grid[clean] = value.strip()
        else: 
            grid[clean] = value.strip()

    return grid


def check_grid_dict_contents(grid, warnings):
    """
    Checks form contents for invalid parameters and adds the appropriate warnings to the warning list.

        :param grid: Dictionary containing the grid parameters from the form
        :returns: None
    """
    if not isinstance(grid["latitudepoints"], str) and not isinstance(grid["longitudepoints"], str):
      if grid["latitudepoints"] == 0 or grid["longitudepoints"] == 0:
          add_form_content_warning("User has entered a zero value in a field that requires a positive integer.", 
                                   warnings)


def create_grid_json_filename(grid, database, warnings): 
    """
    Generates consistantly formatted filename from the form contents e.g.'g-<type>-<number index>.json'.

        :param grid: Dictionary containing the grid parameters from the form
        :returns: Formatted filename of the json file
    """
    if grid["type"] == "simple":
        type = "s"
    elif grid["type"] == "complex":
        type = "c"

    numbers = []
    for f in database.iterdir():
        id = int(f.stem.split("-")[-1])
        numbers.append(id)
    id = max(numbers)+1

    output = f"g-{type}-{id:04d}.json"
    file = database / output
    
    if file.exists(): 
        add_form_content_warning(f"WARNING: THIS GRID IS A DUPLICATE, see database under {file}.", warnings)
    
    return file


def dump_grid_to_json(grid, output):
    """
    Dumps and writes the dictionary contents to a json file with the formatted name. The function also outputs the 
    filename and duplicate status as a variable so it cant be printed to the body of the PR.

        :param grid: Dictionary containing the grid parameters from the form
        :param output: Formatted filename of the json file
        :returns: None
    """
    with open(output, "w") as f:
        json.dump(grid, f, indent=2)
    print(f"Json file created successfully, file saved as {output}")


def json_schema_grid_check(grid, warnings):
    """
    Checks the dictionary contents against a predefined scheme to ensure valid contents and consistency.

        :param grid: Dictionary containing the grid parameters from the form
        :raises ValidationError: Raises an exception if the dictionary has an entry of unexpected type, as defined by 
        the schema

    """
    schema = {
        "type":"object",
        "properties":{
            "griddescription":{
                "type" : "string"
            },
            "type":{
                "type":"string"
            },
            "latitudepoints":{
                "type":"number"
            },
            "longitudepoints":{
                "type":"number"
            }
        }
    }

    try:
        validate(instance=grid, schema = schema)
        print("Validation check passed successfully")
    except Exception: 
        add_form_content_warning("The grid contents has failed the validation check: please verify contents.", warnings)

   
def main():
    """
    Holds the main body of the script.

        :returns: None
    """
    warnings = []

    args = set_arg_parser()
    with open(args.file, "r") as f:
        form = f.read()

    # Find key-value pair matches using markdown structure generated by the yaml file
    match = re.findall(r"### (.+?)\n\s*\n?(.+)", form)
    grid = create_grid_dict(match, warnings)
    check_grid_dict_contents(grid, warnings)

    # Check that the database directory exists and save file
    database = Path("grid-database")
    if not database.exists() or not database.is_dir():
        database.mkdir()
    file = create_grid_json_filename(grid, database, warnings)
    dump_grid_to_json(grid, file)
    json_schema_grid_check(grid, warnings)

    # Write parameters out to github environment to be printed within the body of the pull request
    with open(os.environ["GITHUB_OUTPUT"], "a") as out:
        out.write(f"json_file={file}\n")
        out.write(f"\nwarnings={warnings}")

  
if __name__ == "__main__":
    main()